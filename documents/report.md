# 《人工智能》课程设计报告

## 摘要

笔者运用在AI导论课程中所学习到的知识， 运用reactWeb应用框架和socket.io库， 简单实现了一个在线五子棋游戏系统， 支持房间系统、人机对战、机器与机器对战等功能。其中ai方面使用到了$\alpha-\beta$剪枝算法与启发式函数。

测试游戏时如果只有一个人，可以打开多个网页来模拟多个人在线。

最终成品的代码：[仓库地址](https://github.com/FlashLizard/gobang)

最终的成品笔者也部署在了个人的云服务器上：[网址](http://gobang.flashlizard.tk/)

## 开发工具

1. vscode文本编辑器
2. node.js环境（包括npm包管理工具等）
3. typescript编程环境
4. reactWeb应用框架
5. socket.io库
6. git版本管理工具

## 基本需求

1. 编写前端网页，能够显示棋盘、房间等信息，能够满足玩家的互动（游戏中的操作、对房间的操作）需要。
2. 编写后端房间管理系统，能够实现玩家动态地加入与退出房间，房主对房间的管理（踢人，改变玩家类型），玩家观战，
   空房间的自动删除。
3. 编写后端游戏系统，能够通知游戏方行动，实现五子棋游戏的流程，判断游戏的结果。
4. 编写AI，使用$\alpha-\beta$剪枝算法与启发式函数，有基本的智能。
5. 编写前后端通讯的程序。

其中以下几个方面可以更详细地说明需求

### 前端需求

1. 玩家的登录
2. 游戏主页面（可以快速开始游戏，创建房间，查看房间列表）
3. 房间管理页面（可以管理在房间中的玩家与机器）
4. 房间列表页面（可以显示存在的房间，加入房间，观战）
5. 游戏页面（可以渲染棋盘，进行游戏，或者进行观战）

### ai需求

1. 实现$\alpha-\beta$剪枝算法的基本框架API，支持泛型，方便重复使用该框架。
2. 利用上面实现的框架实现适用于五子棋的$\alpha-\beta$剪枝算法。
3. 设计出一个合理的对当前局面进行评估的启发式函数。
4. 综合以上两者实现AI

## 知识表示

想要全面的表示五子棋棋盘的某个状态，就必须知道当前棋盘的每个格子上的情况。同时，虽然知道棋盘状态也可以推算出当前的行动者是先手方还是后手方，但为了方便起见，还是直接把这个信息记录下来比较好。

综上所述，笔者使用了一个15*15的number的二维数组（记为B）与当前的行动者（准备下棋）在房间中的顺序（记为T）的组合{B，T}来表示一个游戏局面。其中二维数组的-1表示该格子未被下棋，0表示黑子，1表示白子。T的0表示先手方，1表示后手方。

## 算法实现

### ai部分

笔者把这部分分为$\alpha-\beta$剪枝算法,F(S),E(S)和B(S)四个部分进行说明。

#### $\alpha-\beta$剪枝算法

$\alpha-\beta$剪枝算法，或者称为min-max剪枝算法实际上是对搜索算法的优化。它适用于2人对战的回合游戏。为方便说明，我们先定义一些函数。

定义函数F(S)，其中S表示当前局面，F(S)是对当前局面的一个估计评分，F(S)越大，当前局面对我方越优。

定义函数E(S)，其中S表示当前局面，E(S)返回我方胜利时返回inf，对方胜利时返回-inf，游戏未结束时返回null，平局返回-1。

定义函数B(S)，其中S表示当前局面，B(S)返回当前局面再进行一步操作的所能达到的所有分支

每询问对当前局面S我们该如何下棋最优时，我们进行如下操作：

1. 初始化score为-inf（负无穷大），集合A为B(S)，C为空集。
2. 定义变量s。
3. 若A为空，跳到步骤8，否则取出A中的一个元素a，判断E(a)，若返回值为inf，则赋值给s，跳到步骤7，
   否则说明游戏未结束，继续步骤4。
4. 初始化集合A'为B(a)，令s为inf。
5. 若A'为空，跳到步骤7，否则取出A'的一个元素b，记录E(b)，若不为null，则和F(b)取最小值，再与s取最小值赋值给s；若为null，则F(b)与s取最小值赋值给s。
6. 若s小于score，跳转到步骤7（**说明该min节点的分数只可能比score小了，max节点不可能考虑该节点的分支了，所以剩下的直接不考虑**）。
   否则跳到步骤5，继续遍历min节点的子局面。
7. 若s大于score，更新score为s，清空C并把a加入C中；若s等于score，把a加入C中。跳到步骤3。
8. 随机（有随机要素）取出C中的一个元素作为选择返回。

这就是$\alpha-\beta$剪枝算法的普适步骤，可见我们对于一个具体的游戏只要定义好函数F(S),E(S)和B(S)就可以套用这个框架了。接下来笔者就五子棋的这三个函数进行说明。

#### F(S)启发式评估函数

井字棋的评估函数是直接枚举这个局面所能达到的所有获胜局面的数量, 然后双方的获胜数相减得到当前局面的评估分数。而五子棋棋盘大, 用这个方法是绝对行不通的. 我们要换个思路, 用类似于贪心的想法, 用启发式函数去对当前的局面进行评估。

首先, 如果当前局面已经有结果了, 应该就不会进行到这一步（参考之前的结果判断函数E(S)）。所以当前局面还不能直接看出胜负。

总分数S最开始为0，给定参数m，n，k。这里的m，n，k参数的具体值会由笔者后面经过测试给出。

首先站在我方的角度来评估, 令分数$S_1$初始为0. 棋盘上每个格子都对它的4个方向(右,右下,左下, 左)的分别进行如下操作:
沿着当前方向看5个格子(包括当前), 如果其中包含对方棋子, 总分数不加; 不包含的话, 计我方的棋子数为a, 我方棋子的连接处数目为b(连接处的意思是, 两个同色棋子挨在一块的中间那条缝), 然后对总分数这样操作:

$$ S1 += a^m + (b*n)^k $$

这样操作是基于同方向棋子越多越好, 与连接处越多越好的贪心想法去考虑的。
每个棋子的每个方向都要这样操作一遍. 可以发现, 被围起来的棋子或者在边界的棋子对S的贡献会更少, 因为它更可能在操作时碰到对方棋子或边界, 这样它参与计算的次数会比较少.。这也符合我们的通常的贪心想法。

然后类似的计算处对方的评估分数$S_2$。计算完后令S为:

$$ S = S_1 - S_2 $$

这个S就是对当前局面的评分。

#### E(S)结果判断函数

分别对棋盘的每一行每一列每一左下方向每一右下方向以5个格子长度的移动窗口进行移动，如果5个格子都同色，就可以返回结果。如果每个格子都有棋子但没有结果就说明平局。否则说明游戏还未结束。

#### B(S)分支集合函数

这里笔者采取了两种方法。

1. 法一：

   考虑到棋盘很大, 而刚开始时其实我们下棋只会局限在一个小范围内, 所以我们做如下优化: 对于当前棋盘, 取能包含所有棋子的最小矩形, 把这个矩形向上下左右四个方向扩展一个格子成为稍微大一点的矩形, 以这个矩形的范围作为我们下棋位置的集合.

   那么, 游戏进行到后面, 这个矩形难免会变得和棋盘一样大, 怎么办? 考虑到当游戏进行到这个程度时, 其实双方下棋已经比较多了,而下过棋的位置是不需要作为下棋选择去拓展节点的, 所以如果选择的矩形变大, 那么矩形内部的可选择的格子大概率是不多的. 这样我们保证了选择的数量是远远达不到15*15这个上限的.

2. 法二

   枚举当前的每一个棋子，把以该棋子为中心的5*5范围内的空格子作为下棋集合返回。

经过尝试，笔者最后采用了法一。

### 房间，玩家，游戏的管理部分

只对这部分作简单说明

1. 前端玩家登入游戏，socket.io返回登录信息，后端根据信息实例化类Player。
2. 前端玩家创建房间，socket.io返回该信息，后端根据信息初始化实例Room，并返回是否处理成功的信号给前端。由前端判断是否该跳转到房间管理页面。
3. 前端玩家加入房间，socket.io返回该信息，后端根据信息把Player加入Room的characters属性中，并返回是否处理成功的信号给前端。由前端判断是否该跳转到房间页面。
4. 前端玩家管理房间，socket.io返回该信息，后端根据信息对Room进行相应操作（踢人，改变ai类型，改变顺序等），并返回处理结果给前端。前端重新渲染房间。
5. 前端玩家开始游戏，socket.io返回该信息，后端根据玩家所在的Room实例化类Game，并执行Game的函数run开始游戏，并返回是否处理成功的信号给前端。由前端判断是否该跳转到游戏页面。
6. 前端玩家观战，socket.io返回该信息，后端将Player加入到Game的audiences属性中，并返回是否处理成功的信号给前端。由前端判断是否该跳转到游戏页面。

### 游戏流程部分

同上，只对该部分进行简单说明，该部分运行在后端。

1. 初始化turn为0，board为15*15全为-1的二维数组。
2. 通过socket.io向顺序为turn的对象（可能为玩家，也可能为ai）发送请求操作的信号，并等待下棋位置的信息返回。
3. 若返回信号超时，则判断turn对象放弃游戏，向所有玩家和观战者返回游戏结果。否则执行返回回来的下棋操作。
4. Game向所有玩家和观战者返回游戏信息。
5. 判断当前游戏是否结束，若结束，向所有玩家和观战者返回游戏结果，否则更新turn，跳转到步骤2。

## 运行展示

